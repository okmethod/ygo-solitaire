# 課題とコンセプトの定義

1. 課題と目的 (Why)

課題:

TCG（トレーディングカードゲーム）の「ソリティア（1人で延々とコンボを回す行為）」は、実カードで練習するとシャッフルや準備が面倒である。

複雑な手順を記憶する必要があり、手順ミスが発生しやすい。

特定の初手から勝利までのルートを検証したいニーズがある。

目的:

Web ブラウザ上で手軽に「先攻1ターンキル（FTK）」のコンボ練習ができる環境を提供する。

ルール処理を自動化し、正しい手順を学習できるようにする。

2. コンセプト (Concept)

「詰将棋」のような感覚でプレイする、TCG 1ターンキル・シミュレーター

ユーザーはデッキを選ぶだけで、即座にゲームを開始できる。

面倒な対戦相手の思考待ち時間はゼロ（対戦相手はカカシ）。

パズルを解くように勝利条件を目指す。

3. スコープ (Scope)

やること (In Scope)

デッキ選択機能: あらかじめ定義された数種類のコンボデッキから選択して開始する。

先攻1ターン目のシミュレーション: ドローフェイズからエンドフェイズ（または勝利）まで。

勝利判定: エクゾディア揃い、相手ライフ 0 などの特殊勝利・バーン勝利の判定。

基本的なルール処理: カードの発動、チェーン処理、召喚、墓地送り等の基本ロジック。

プリセットカードの実装: 選択可能なデッキに含まれるカードのみを実装する。

やらないこと (Out of Scope)

デッキ構築機能: ユーザーが自由にデッキを組む機能は実装しない（複雑度爆発の防止）。

後攻・対戦相手のAI: 相手は一切妨害してこない「壁」とする。

バトルフェイズ: 先攻1ターン目限定のため、攻撃処理は実装しない。

完全なルール網羅: 選択されたデッキで発生しないレアなルール処理（例: 複雑な巻き戻し処理など）は実装しない。

サーバーサイド: ユーザーデータの保存やマルチプレイは行わない（完全クライアントサイド）。

4. MVP (Minimum Viable Product)

デッキ: 「封印されしエクゾディア」デッキ 1種。

機能: 手札からの魔法発動、ドロー、手札抹殺などによる手札入れ替え、勝利判定のみ。

UI: 盤面が見え、カードをドラッグ＆ドロップ（またはクリック）でプレイできる最低限の画面。

# ドメインモデルと用語定義

1. ユビキタス言語 (Ubiquitous Language)

開発チームとドメイン（カードゲーム）の共通言語。

領域 (Zone)

Deck (デッキ): 山札。ここからカードを引く。

Hand (手札): プレイヤーが持っているカード。プレイの起点。

Field (フィールド): モンスターゾーン、魔法・罠ゾーンの総称。

Graveyard (墓地): 使用済みのカードが送られる場所。

Banishment (除外): ゲームから除外された場所。

行動 (Action)

Draw (ドロー): デッキの一番上からカードを手札に加える。

Summon (召喚): モンスターをフィールドに出す。

Activate (発動): 魔法カードを使用する、またはモンスター効果を使用する。

Set (セット): カードを裏側表示でフィールドに置く。

Release (リリース): コストとしてモンスターを墓地へ送る。

概念 (Concept)

Chain (チェーン): 効果の発動に対して、別の効果を発動すること。LIFO（後入れ先出し）で解決される。

Cost (コスト): 効果を発動するために支払う代償（ライフ、手札捨て等）。効果無効になっても返ってこない。

Effect (効果): カードが持つ固有の処理内容。

2. アクター (Actor)

Player (プレイヤー): ゲームを操作する主体。

System (システム/ジャッジ): ルールを監視し、処理を実行する主体。相手プレイヤーの代わりも兼ねる。

3. 業務フロー / ユースケース

UC01: ゲーム開始

Player はデッキを選択する。

System はデッキデータをロードし、シャッフルする。

System は Player に初期手札（5枚）を配る。

デュエル開始（LP 8000）。

UC02: カードのプレイ（魔法カード発動）

Player は手札の魔法カードを選択し、発動を宣言する。

System は発動条件（コスト、対象など）をチェックする。

条件を満たす場合、カードをフィールド（魔法罠ゾーン）に置き、チェーンブロックを作成する。

（相手の妨害はないため）チェーン解決処理に移る。

System はカードの効果処理（例：2枚ドロー）を実行する。

効果処理後、カードを墓地へ送る。

UC03: 勝利判定

処理の完了時、常に勝利条件をチェックする。

「エクゾディアパーツが手札に5枚ある」または「相手LPが0になる」場合、Player の勝利とする。

# システム仕様

1. 前提条件と制約

プラットフォーム: モダンブラウザ (Chrome, Edge, Firefox, Safari)

言語: TypeScript (Strict mode)

フレームワーク: Svelte 5 + Tailwind CSS

動作環境: クライアントサイドのみで完結（スタンドアロンSPA）

2. データ要件 (Data Model)

Card (カード情報)

不変（Immutable）なデータ。JSONで定義。

interface CardData {
  id: string;
  name: string;
  type: 'Monster' | 'Spell' | 'Trap';
  text: string;
  // 属性、レベル、攻撃力などは必要に応じて追加
}


GameState (ゲーム状態)

可変（Mutable）な状態。

interface GameState {
  zones: {
    deck: CardInstance[];
    hand: CardInstance[];
    monsterZone: (CardInstance | null)[];
    spellTrapZone: (CardInstance | null)[];
    graveyard: CardInstance[];
  };
  lp: {
    player: number;
    opponent: number;
  };
  phase: 'Draw' | 'Standby' | 'Main1' | 'End';
  chainStack: ChainBlock[];
}


3. 機能要件 (Functions)

ゲームエンジン (Game Engine)

Action Dispatcher: UIからの操作（「このカードを手札から出す」）を受け取る。

Rule Validator: その操作がルール上適正かチェックする（空きゾーンがあるか、コストは足りているか）。

State Reducer: 操作に基づいて GameState を更新する（純粋関数的な振る舞い推奨）。

Effect Resolver: カード固有の効果ロジックを実行する。

カード効果の実装

カードごとに実装クラスまたは関数を用意する（Strategy Pattern）。

例: PotOfGreedEffect (強欲な壺) -> draw(2)

4. 画面(UI)要件

メイン画面 (Duel Board)

手札エリア: 自分の手札を並べて表示。クリック/ドラッグで操作可能。

フィールドエリア: モンスターゾーン(5枠)、魔法罠ゾーン(5枠)、墓地、デッキを表示。

ステータスエリア: 現在のLP、デッキ枚数を表示。

ログエリア: 「強欲な壺を発動」「2枚ドロー」などの行動ログを表示。

操作インタラクション

カードをクリックすると、可能なアクション（発動、召喚、セット）のメニューが出る。

対象選択が必要な場合（例：死者蘇生）、対象カードをハイライトして選択させる。

5. 非機能要件

レスポンス: カードプレイ時のアニメーションや処理落ちが起きないこと（State更新の最適化）。

拡張性: 新しいデッキ（新しいカード）を追加する際、既存のエンジンコードを修正せずに済むこと。