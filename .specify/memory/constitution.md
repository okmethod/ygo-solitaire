<!--
Sync Impact Report:
Version: 2.0.0 (major revision - fundamental principles redesigned)
Modified Principles:
  - 全原則を開発哲学ベースに再構築
  - 実装詳細依存を排除し、普遍的な原則に変更
Added Sections:
  - Planning Principles (要件定義の心得)
  - Architecture Principles (設計の心得)
  - Coding Principles (実装の心得)
  - Project-Specific Principles (このプロジェクト固有の原則)
Removed Sections:
  - 旧Core Principles (実装詳細に依存した原則5つを削除)
Templates Status:
  - ✅ spec-template.md: Reviewed - 新しい原則と整合
  - ✅ plan-template.md: Reviewed - Constitution Checkセクションで新原則を参照可能
  - ✅ tasks-template.md: Reviewed - 新しいワークフローと整合
Follow-up TODOs:
  - 次回の設計見直し時に、原則IVの各レイヤーの責務を具体化する可能性あり
-->

# Yu-Gi-Oh! ソリティア プロジェクト憲法

## 大原則

**本質的に必要なものを深く考え、ベターな最適解を選び抜き、理解しやすいコードを書く**

この憲法は、プロジェクトのすべての意思決定の基準となる。特定の実装方法ではなく、判断の軸となる価値観を定義する。

---

## Planning Principles（要件定義の心得）

### I. 目的と手段の分離

**Why（目的）とWhat/How（手段）を明確に分離して考える**

- 機能を追加する前に「なぜそれが必要か」を問う
- 「こう実装したい」ではなく「こういう価値を提供したい」から始める
- 迷ったときは目的に立ち返る

**根拠**: 手段に囚われると本質を見失う。目的が明確なら、より良い手段を選択できる。

**このプロジェクトでの適用例**:
- ❌ 「カード効果クラスを実装したい」
- ✅ 「プレイヤーが遊戯王のコンボを体験できるようにしたい → そのためにカード効果のシミュレーションが必要」

### II. 段階的な理解の深化

**要求 → 要件 → 仕様 の段階を経て、システムの姿を収束させる**

- 最初から完璧な仕様は作れない前提で進める
- 各段階で「何がわかったか」「何が未決定か」を明確にする
- 後の段階で判明した本質的な問題は、前の段階に戻って見直す

**根拠**: 理解は段階的に深まる。一度で完璧を目指すより、反復的に改善する方が良い結果を生む。

---

## Architecture Principles（設計の心得）

### III. 最適解の選択と記録

**正解を探すのではなく、ベターな最適解を選び抜く**

- 完璧なアーキテクチャは存在しない
- トレードオフを理解し、現状で最良の選択をする
- **重要**: 設計判断の根拠を必ず記録する（ADR推奨）

**根拠**: すべての設計にはトレードオフがある。判断の根拠を記録することで、将来の変更時に「なぜこうしたか」が理解できる。

**記録すべき内容**:
- 選択した設計アプローチ
- 検討した代替案
- 選択の理由（トレードオフの評価）
- 想定される制約・前提条件

### IV. 関心の分離（Separation of Concerns）

**システムを適切なレイヤー・コンポーネントに分割し、責務の境界を明確にする**

- **ゲームロジック**: カードルール、効果処理、勝敗判定（フレームワーク非依存）
- **インターフェース層**: 操作の受付、状態の問い合わせ（UIから分離）
- **UI層**: 表示と操作トリガー（プレゼンテーション責務に特化）

**依存の方向**:
- UI → インターフェース層 → ゲームロジック（依存OK）
- ゲームロジック → UI（依存NG）

**根拠**: 関心を分離することで、各レイヤーを独立してテスト・変更・再利用できる。適切にモデル化できていれば、ゲームエンジン部分の切り出しは容易なはず。

**このプロジェクトでの適用例**:
- DuelStateクラスはSvelteコンポーネントに依存してはならない
- カード効果の処理は、UIの存在を知らない
- UIコンポーネントは状態を表示するだけで、ゲームルールを実装しない

### V. 変更に対応できる設計

**将来の変更を予測して過剰設計するのではなく、変更しやすい構造を保つ**

- 単一責任原則（SRP）: 変更理由は1つに
- オープン・クローズド原則（OCP）: 拡張に開き、修正に閉じる
- 依存性逆転原則（DIP）: 抽象に依存し、具象に依存しない

**根拠**: 将来何が必要になるかは予測できない。重要なのは、必要になったときに変更しやすいこと。

---

## Coding Principles（実装の心得）

### VI. 理解しやすさ最優先

**コードは書く時間より読まれる時間の方が長い。理解しやすさを最優先する**

- 簡潔さより明確さを選ぶ
- 将来の自分や他人が読むことを想定する
- 「これは理解しやすいか？」を常に問う

**具体的な実践**:
- **命名**: 目的と内容が明確にわかる名前
- **コメント**: コードが「何をするか」ではなく「なぜそうするか」を説明
- **関数**: 単一の明確な責務、適切な粒度
- **複雑な式**: 一時変数で分解し、意図を明示

**根拠**: コードは人間が読むもの。読解時間を最小化することが、長期的な生産性向上につながる。

### VII. シンプルに問題を解決する

**複雑な問題をシンプルに解決する。過剰な抽象化や早すぎる最適化を避ける**

- YAGNI（You Aren't Gonna Need It）: 今必要でない機能は実装しない
- まず動くシンプルな実装、必要になったらリファクタリング
- 抽象化は3回同じパターンが現れてから

**根拠**: 過剰な抽象化は理解を妨げ、保守コストを上げる。本当に必要になってから抽象化する方が、適切な設計になる。

### VIII. テスト可能性を意識する

**最初からテスト可能な設計にする。テストしにくいコードは設計の問題**

- 純粋関数を優先（副作用を境界に押し出す）
- 依存を注入可能にする（DIパターン）
- UIなしでビジネスロジックを完全にテスト可能

**根拠**: テスト可能な設計は、疎結合で責務が明確な設計。テストは品質保証だけでなく、設計の良し悪しを測る指標。

---

## Project-Specific Principles（このプロジェクト固有の原則）

### このアプリケーションの本質

**遊戯王カードの1ターンキルコンボをシミュレートするWebアプリケーション**

- あらかじめ選んだカード・デッキのみを実装（全カードプールは対象外）
- 限定的なスコープのため、プログラミングはシンプルで済むはず
- 複雑なカードゲームのルールをモデル化し、ゲームエンジン・I/F・UIを分離

### IX. 技術スタック（現時点の選択）

**スタンドアロンSPA: TypeScript + Svelte + TailwindCSS**

この選択は暫定的であり、より良い選択肢が見つかれば変更可能。

**技術選択の根拠**:
- TypeScript: 型安全性による保守性向上
- Svelte: リアクティビティとシンプルさの両立
- TailwindCSS: 一貫したデザインシステム

**技術スタック選択時の判断基準**:
- プロジェクトの本質（カードゲームシミュレーション）に適しているか
- チームの習熟度（学習コスト vs 生産性）
- 将来の拡張性（ゲームエンジン切り出しを妨げないか）

---

## Development Workflow（開発フロー）

### 作業の進め方

#### 1. ブランチ戦略（NON-NEGOTIABLE）

- **mainブランチへの直接コミット禁止**
- すべての変更は専用ブランチで実施: `feature/<機能名>`, `fix/<修正内容>`, `refactor/<対象>`
- 変更完了後は必ずPRを作成し、レビューを経てマージ

**根拠**: 履歴の保護と変更の追跡可能性。mainは常にデプロイ可能な状態を保つ。

#### 2. コミット前の品質保証（NON-NEGOTIABLE）

- **動作確認**: 実装が期待通りに動作することを確認
- **Linter/Formatter実行**: エラーゼロの状態でコミット
- **テスト実行**: 既存テストが壊れていないことを確認

**根拠**: コードベースの品質維持と、レビュー負担の軽減。

#### 3. コミットメッセージ

- 明確で簡潔に: `feat: ドロー効果の基底クラスを実装`, `fix: 手札枚数の計算ロジックを修正`
- Conventional Commits推奨: `feat`, `fix`, `refactor`, `docs`, `test`, etc.

### PR作成時

- **目的**: なぜこの変更が必要か
- **変更内容**: 何を変更したか（コードだけでわからない文脈）
- **設計判断**: トレードオフや代替案を検討した場合は記載
- **テスト方法**: どう確認すればよいか

---

## Testing Strategy（テスト戦略）

### テストの目的

- 品質保証だけでなく、設計の検証
- リファクタリングを安全に行うための保険
- 仕様の生きたドキュメント

### テストレベル

1. **単体テスト**: ゲームロジック（カード効果、状態遷移）
2. **統合テスト**: レイヤー間の連携（I/F層 ↔ ゲームロジック）
3. **E2Eテスト**: ユーザーシナリオ（必要に応じて）

### テストの原則

- **UIなしでビジネスロジックをテスト可能**: ゲームエンジンはSvelteに依存しない
- **非同期処理は明示的にテスト**: Promiseは`await`でテスト
- **エッジケースを網羅**: 手札が空、デッキ切れ、無効な操作など

### ツール（現時点）

- **フロントエンド**: Vitest + Testing Library
- **Linter**: ESLint + Prettier（フロントエンド）

---

## Governance（ガバナンス）

### 憲法の位置づけ

この憲法は、プロジェクトのすべての開発実践に優先する。CLAUDE.mdと併用し、実務的な詳細はCLAUDE.mdに記載する。

### 憲法の改定

- **MAJOR改定**: 原則の削除・根本的な再定義（例: 今回の2.0.0改定）
- **MINOR改定**: 新しい原則の追加、既存原則の大幅な拡張
- **PATCH改定**: 文言の明確化、誤字修正、例の追加

改定時は必ず根拠を記録し、依存テンプレート（spec/plan/tasks）との整合性を確認する。

### コンプライアンス

- すべてのPRはこの憲法の原則に準拠
- 原則に反する変更は、明確な根拠と正当化が必要
- 設計判断の根拠を記録（ADR、コメント、PR説明など）

### ガイダンスファイル

- **開発哲学**: この憲法（constitution.md）
- **実務詳細**: CLAUDE.md（Claude Codeとの作業時の具体的なガイド）
- **プロジェクト概要**: README.md（全体像と起動方法）

---

## References（参考資料）

- [Planning Guide](https://github.com/okmethod/okmethod/blob/main/docs/planning-guide/README.md) - 要件定義の心得
- [Architecting Guide](https://github.com/okmethod/okmethod/blob/main/docs/architecting-guide/README.md) - アーキテクチャ設計の心得
- [Coding Guide](https://github.com/okmethod/okmethod/blob/main/docs/coding-guide/README.md) - コーディングの心得

**Version**: 2.0.0 | **Ratified**: 2025-01-23 | **Last Amended**: 2025-01-23
